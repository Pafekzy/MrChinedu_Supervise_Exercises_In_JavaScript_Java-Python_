Here’s a reorganized version of the task requirements for clarity and better flow:

---

### **Java MultiPalindrome Checker Task**

You are required to create a Java application with multiple classes and methods that determine if a given input (either numbers or words) is a **strict palindrome** or **unstrict palindrome**. The implementation should follow these guidelines:

#### **Main Requirements**

1. **Switch Case Menu**:
   - Create a method that presents a menu to the user with options to choose from:
     - Strict Palindrome Numbers
     - Strict Palindrome Words
     - Unstrict Palindrome Numbers
     - Unstrict Palindrome Words
   - Based on the user’s choice, the corresponding palindrome-checking method will be invoked.

2. **Input Validation**:
   - Create a method that ensures the user enters **two or more inputs**, either **numeric** or **alphabetical**.
   - The method should enforce the minimum input requirement and guide the user to provide the appropriate type of data.

3. **Strict Palindrome Methods**:
   - Create methods to handle **strict palindrome checks**:
     - A method that collects a number from the user and checks if it is a strict palindrome (exact reverse of the number).
     - A method that collects one or more words from the user and checks if they form a strict palindrome (exact reverse of the word/phrase).

4. **Unstrict Palindrome Methods**:
   - Create methods to handle **unstrict palindrome checks**:
     - A method that collects a number from the user and checks if it is an unstrict palindrome (ignoring case, spaces, and punctuation).
     - A method that collects one or more words from the user and checks if they form an unstrict palindrome (ignoring case, spaces, and punctuation).

5. **User-Friendly Output**:
   - Create a method to **format the output** of the palindrome checks in a user-friendly tone, ensuring that the results are clearly presented to the user.

6. **Welcoming Function**:
   - A method that displays a welcome message:  
     `"Welcome to Joseph's MultiPalindrome Checker"`.

7. **Exception Handling**:
   - Create a method that handles numeric input exceptions using **if-else** statements, with detailed messages for validation errors.
   - Exception messages should clearly explain the **exact reason** for invalid inputs and guide the user toward correcting them.

---

#### **Development Guidelines**

1. **Class Structure**:
   - **Multiple Classes**: 
     - One main class containing all the core methods and logic.
     - A secondary class for managing the flow of the program (menu handling, calling specific methods, and managing user inputs).
   - The secondary class should be as concise as possible, while the main class will contain all the functional methods.

2. **Avoid Inbuilt Methods**:
   - Emphasis is placed on creating **custom methods** rather than using inbuilt Java methods.
   - Each method should perform **one task only** and perform it well (following **Single Responsibility Principle**).

3. **Helper Methods**:
   - Break down logic into **helper methods** to ensure each method handles only a specific part of the task (e.g., one method for removing spaces, one for case normalization, etc.).

4. **Detailed Exception Handling**:
   - Edge cases should be handled accurately, and all exceptions must return **friendly and descriptive** error messages that explain what was wrong with the user’s input.

5. **Unstrict Palindrome Rules**:
   - For unstrict palindrome checks, implement logic that **ignores case**, **spaces**, and **punctuation** when evaluating inputs.

---

#### **Test-Driven Development (TDD)**

- Implement **TDD**, writing **28 or more test cases** that comprehensively test the various functions and methods.
- Ensure tests are written **first**, ensuring all the methods pass these tests upon implementation.

---

#### **Key Notes**

1. **Method Naming**:
   - Avoid comments by ensuring all variable names, method names, and class names are clear and meaningful. Method names should **describe their purpose** accurately.
   
2. **Method Structure**:
   - Each method must do **one thing only**. Break down complex tasks into multiple, simpler helper methods to keep the code clean and modular.

---

By structuring the requirements in this way, each task is clear, and the flow of development is more organized. Let me know if you'd like to proceed with code samples or further clarifications!